---
title: "STAT293_GIMME"
author: "Yijia Xue"
output: pdf_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r}
library(MASS)
library(gimme)
library(dplyr)
library(ggplot2)
library(qgraph)


if (dir.exists("sim_data"))    unlink("sim_data", recursive = TRUE)
if (dir.exists("sim_results")) unlink("sim_results", recursive = TRUE)

dir.create("sim_data",    showWarnings = FALSE)
dir.create("sim_results", showWarnings = FALSE)
```

# 1. Helper functions

## 1.1 Generate $\Psi_i$

Covariance matrix for white noise $\zeta$

```{r}
generate_Psi_i <- function(A_i,
                           min_k = 1,
                           max_k = 4,
                           base_var = 1.5,
                           low_cov = 0.03,
                           high_cov = 0.15) {
  p <- nrow(A_i)
  Psi <- diag(base_var, p, p)
  
  # candidate off-diagonal positions where A_i has zero and use only i < j to enforce symmetry
  candidates <- which(A_i == 0, arr.ind = TRUE)
  candidates <- candidates[candidates[,1] < candidates[,2], , drop = FALSE]
  if (nrow(candidates) == 0) return(Psi)
  
  k <- sample(min_k:max_k, 1)
  k <- min(k, nrow(candidates))
  chosen_idx <- sample(1:nrow(candidates), k, replace = FALSE)
  chosen <- candidates[chosen_idx, , drop = FALSE]
  
  # assign random covariances at those positions
  for (m in 1:nrow(chosen)) {
    i <- chosen[m, 1]
    j <- chosen[m, 2]
    val <- runif(1, low_cov, high_cov)
    Psi[i, j] <- val
    Psi[j, i] <- val
  }
  
  # ensure positive definite 
  ev <- eigen(Psi, symmetric = TRUE)$values
  if (min(ev) <= 0) {
    jitter <- (abs(min(ev)) + 1e-3)
    Psi <- Psi + jitter * diag(p)
  }

  return(Psi)
}

```

######### Simulate one subject given $A_i$ and $\Phi_i$

$\eta_{t} = A_{i}\,\eta_{t} + \Phi_{i}\,\eta_{t-1} + \zeta_{t}$

$[\eta_{t}=(I - A_{i})^{-1}\left[\Phi_{i}\,\eta_{t-1} + \zeta_{t}\right]$

## 1.2 Simulate $\eta_i$

```{r}
simulate_subject_total <- function(T_total, A, Phi, Psi) {
  p <- nrow(A)
  
  X <- matrix(NA, nrow = T_total, ncol = p)
  colnames(X) <- paste0("X", 1:p)

  # initial state eta_1 
  X[1, ] <- runif(p,min=0, max=0.5)

  # (I - A)^(-1)
  M <- solve(diag(p) - A)

  for (t in 2:T_total) {
    zeta_t <- mvrnorm(1, mu = rep(0, p), Sigma = Psi)  #zeta is the white noise
    X[t, ] <- M %*% (Phi %*% X[t - 1, ] + zeta_t)
  }

  X
}
```

## 1.3 Random K generator

```{r}
random_k <- function(min_k, max_k) {
  if (max_k <= 0) return(0L)
  sample(min_k:max_k, size = 1)
}

```

## 1.4 Random individual edges generator

```{r}
generate_random_individual_edges <- function(M_common,
                                             min_k = 0,
                                             max_k = 4,
                                             low=0.03,
                                             high=0.15,
                                             allow_diag = FALSE) {

  p <- nrow(M_common)
  M <- M_common

  # 1. Choose how many individual edges this subject gets 
  k_indiv <- random_k(min_k, max_k)
  if (k_indiv == 0) return(M)

  # 2. Find eligible positions (cannot overwrite group edges) 
  possible <- which(M_common == 0, arr.ind = TRUE)

      # optionally remove diagonal
  if (!allow_diag) {
    possible <- possible[possible[,1] != possible[,2], , drop = FALSE]
  }
  if (nrow(possible) == 0) return(M)
  
      # safety: cannot choose more edges than exist
  k_indiv <- min(k_indiv, nrow(possible))

  # 3. Randomly select k edges 
  idx <- sample(seq_len(nrow(possible)), size = k_indiv, replace = FALSE)
  chosen <- possible[idx, , drop = FALSE]

  # 4. Fill with random values ----
  for (j in seq_len(nrow(chosen))) {
    to   <- chosen[j, 1]
    from <- chosen[j, 2]
    M[to, from] <- runif(1,low,high)
  }

      # ensure no diagonals for A
  if (!allow_diag) diag(M) <- diag(M_common)

  M
}
```

## 1.5 Matrix comparison function

```{r}
compare_mats <- function(M_true, M_est, tol = 1e-8) {
  
  # treat any nonzero entry as an edge
  true_edge <- abs(M_true) > tol
  est_edge  <- abs(M_est)  > tol
  
  TP <- sum(true_edge & est_edge)
  FP <- sum(!true_edge & est_edge)
  FN <- sum(true_edge & !est_edge)
  TN <- sum(!true_edge & !est_edge)
  
  data.frame(
    TP = TP,
    FP = FP,
    FN = FN,
    TN = TN,
    sensitivity = ifelse((TP + FN) == 0, NA, TP / (TP + FN)),
    specificity = ifelse((TN + FP) == 0, NA, TN / (TN + FP)),
    precision   = ifelse((TP + FP) == 0, NA, TP / (TP + FP))
  )
}
```

######## End of helper functions

############################################ 

# 2. One simulation loop

```{r}
run_one_sim <- function(T_obs, N = 100, p = 8,
                        group_cutoff = 0.65,
                        seed = NULL,
                        burn_in=100,
                        return_nets=FALSE) {

  if (!is.null(seed)) set.seed(seed)
  
  T_total <- T_obs + burn_in
  
  ## 1. Define group-level A_common 
  A_common <- matrix(0, p, p)
  for (j in 1:(p - 1)) {
    A_common[j + 1, j] <- runif(1, 0.2, 0.35)
  }
  diag(A_common) <- 0

  ## 2. Define group-level Phi_common 
  Phi_common <- matrix(0, p, p)
  diag(Phi_common) <- runif(p, min = 0.1, max = 0.2)
    
    #### To make Phi denser ####
  
    # first off-diagonal band
    for (j in 1:(p - 1)) {
      Phi_common[j + 1, j] <- runif(1, 0.2, 0.3)
    }
    # second off-diagonal band
    for (j in 1:(p - 2)) {
      Phi_common[j + 2, j] <- runif(1, 0.1, 0.2)
    }
    # a few extra random group edges
    extra_edges <- 3
    for (k in 1:extra_edges) {
      r <- sample(1:p, 1)
      c <- sample(setdiff(1:p, r), 1)
      Phi_common[r, c] <- runif(1, 0.03, 0.08)
    }

  ## 3. Simulate N subjects 
  A_list   <- vector("list", N)
  Phi_list <- vector("list", N)
  Psi_list <- vector("list", N)
  X_list   <- vector("list", N)

  for (s in 1:N) {
    # A_i: contemporaneous, no diag, few individual edges (Sparse)
    A_i <- generate_random_individual_edges(
      M_common   = A_common,
      min_k      = 0,
      max_k      = 2,
      low        = 0.03,
      high       = 0.12,
      allow_diag = FALSE
    )

    # enforce: no bidirectional contemporaneous edges
    for (i in 1:p) {
      for (j in 1:p) {
        if (i < j && A_i[i, j] != 0 && A_i[j, i] != 0) {
          A_i[j, i] <- 0
        }
      }
    }

    # Phi_i: lagged, diag allowed, more individual edges
    Phi_i <- generate_random_individual_edges(
      M_common   = Phi_common,
      min_k      = 2,
      max_k      = 5,
      low        = 0.05,
      high       = 0.15,
      allow_diag = TRUE
    )

    # Psi_i: structured noise, off-diagonal only where A_i == 0
    Psi_i <- generate_Psi_i(
      A_i,
      min_k   = 1,
      max_k   = 4,
      base_var = 1,
      low_cov = 0.01,
      high_cov = 0.05
    )

    A_list[[s]]   <- A_i
    Phi_list[[s]] <- Phi_i
    Psi_list[[s]] <- Psi_i

    
    
    X_full <- simulate_subject_total(
      T_total = T_total,
      A       = A_i,
      Phi     = Phi_i,
      Psi     = Psi_i
    )
    
    
   X_list[[s]] <- X_full[(T_total - T_obs + 1):T_total, , drop = FALSE]
   
  }

  ##  4. Write sim_data for this run 
  
 
  for (s in seq_len(N)) {
    fname <- file.path("sim_data", paste0("sub", s, ".txt"))
    write.table(
      X_list[[s]],
      file      = fname,
      row.names = FALSE,
      col.names = TRUE,
      sep       = " "
    )
  }

  ##  5. Run GIMME 

  fit <- gimme(
    data        = "sim_data",
    out         = "sim_results",
    sep         = "",
    header      = TRUE,
    ar          = TRUE,
    plot        = FALSE,
    subgroup    = FALSE,
    paths       = NULL,
    groupcutoff = group_cutoff,
    subcutoff   = .50,
    standardize = TRUE
  )

  ##  6. Extract group-level estimated A and Phi 
  PCM <- as.matrix(read.csv(
    "sim_results/summaryPathCountsMatrix.csv",
    check.names = FALSE
  ))

  p_mat <- nrow(PCM)
  lag_cols   <- grep("lag", colnames(PCM))
  Phi_counts <- PCM[, lag_cols, drop = FALSE]
  A_counts   <- PCM[, -lag_cols, drop = FALSE]
  N_subj     <- max(PCM)

  Phi_est <- (Phi_counts >= group_cutoff * N_subj)
  A_est   <- (A_counts   >= group_cutoff * N_subj)
  Phi_est <- +Phi_est
  A_est   <- +A_est

  rownames(A_est)   <- rownames(PCM)
  colnames(A_est)   <- gsub("lag", "", colnames(A_counts))
  rownames(Phi_est) <- rownames(PCM)
  colnames(Phi_est) <- gsub("lag", "", colnames(Phi_counts))
  diag(A_est) <- 0

  ##  7. Compare true vs estimated (A and Phi) 
  resA  <- compare_mats(A_common,  A_est)
  resPhi <- compare_mats(Phi_common, Phi_est)

  # Add FPR, matrix label, T, and rep placeholders
  resA$FPR   <- with(resA, FP / (FP + TN))
  resPhi$FPR <- with(resPhi, FP / (FP + TN))

  resA$matrix   <- "A"
  resPhi$matrix <- "Phi"

  resA$T_obs   <- T_obs
  resPhi$T_obs <- T_obs

  metrics<-rbind(resA, resPhi)
   if (return_nets) {
    # return both metrics and the actual matrices
    return(list(
      metrics    = metrics,
      A_common   = A_common,
      Phi_common = Phi_common,
      A_est      = A_est,
      Phi_est    = Phi_est
    ))
  } else {
    return(metrics)
  }
}



```


#3. Reproductive simulations

```{r}

Ts <- c(50,150,300)
R  <- 20                # repetitions per T

all_res_list <- list()
idx <- 1

for (tt in Ts) {                 # loop over T
  for (rp in 1:R) {              # loop over repetitions
    cat("Running T =", tt, "rep =", rp, "\n")
    res <- run_one_sim(
      T_obs       = tt,
      N           = 100,
      p           = 8,
      group_cutoff = 0.75,
      seed        = 1000*tt + rp,
      burn_in     = 100
    )
    res$rep <- rp
    all_res_list[[idx]] <- res
    idx <- idx + 1
  }
}

all_res <- do.call(rbind, all_res_list)
head(all_res)


```


#4. Simulation Summary + Plots


## 4.1 Summary Tables for A and $\Phi$
```{r}
# summary for A 

summary_A <- all_res %>%
  dplyr::filter(matrix == "A") %>%
  dplyr::group_by(T_obs) %>%
  dplyr::summarise(
    mean_TPR = mean(sensitivity, na.rm = TRUE),   # TPR
    sd_TPR   = sd(sensitivity, na.rm = TRUE),

    mean_FPR = mean(FPR, na.rm = TRUE),
    sd_FPR   = sd(FPR, na.rm = TRUE),

    mean_spec = mean(specificity, na.rm = TRUE),
    sd_spec   = sd(specificity, na.rm = TRUE),

    #  average counts of FP and FN
    mean_FP = mean(FP, na.rm = TRUE),
    sd_FP   = sd(FP, na.rm = TRUE),

    mean_FN = mean(FN, na.rm = TRUE),
    sd_FN   = sd(FN, na.rm = TRUE),

    #  false negative rate (FNR)
    mean_FNR = mean(FN / (TP + FN), na.rm = TRUE),
    sd_FNR   = sd(FN / (TP + FN), na.rm = TRUE),

    .groups = "drop"
  )

summary_A

# summary for Phi

summary_Phi <- all_res %>%
  filter(matrix == "Phi") %>%
  group_by(T_obs) %>%
  summarise(
    mean_TPR = mean(sensitivity, na.rm = TRUE),
    sd_TPR   = sd(sensitivity, na.rm = TRUE),
    .groups = "drop"
  )
summary_Phi
```

## 4.2 Plot for TPR vs T for A and $\Phi$

```{r}
ggplot() +
  geom_line(data = summary_A, aes(x = T_obs, y = mean_TPR, color = "A")) +
  geom_point(data = summary_A, aes(x = T_obs, y = mean_TPR, color = "A")) +
  geom_line(data = summary_Phi, aes(x = T_obs, y = mean_TPR, color = "Phi")) +
  geom_point(data = summary_Phi, aes(x = T_obs, y = mean_TPR, color = "Phi")) +
  labs(
    x = "T",
    y = "TPR",
    color = "Matrix",
    title = "TPR vs T for A and Phi"
  ) +
  theme_minimal()

```

## 4.3 Plot for A recovery across T

```{r}
ggplot(summary_A, aes(x = T_obs, y = mean_TPR)) +
  geom_line() +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_TPR - sd_TPR,
                    ymax = mean_TPR + sd_TPR),
                width = 10) +
  labs(
    x = "T (time points per subject)",
    y = "True Positive Rate (TPR) for A",
    title = "Group-level recovery of contemporaneous edges (A) across T"
  ) +
  theme_minimal()

```

1/3 talking about model, 1/3 what we accessed

more systematic datasets (20 times, so 60 times in total) try n=100,
T=50, n=100, T=150 n=100, T=200 replicate estimation 20 times

TP,TN, FP, FN, Sensitivity, Specificity,... avg of those 20 runs


## 4.3. network plot

(One example network plot from each T=50,150,300.(One run from each T) Just for demonstration.)

```{r}

#### Getting one sample simulation from each T

run_50  <- run_one_sim(T_obs = 50,  N = 100, p = 8,
                       group_cutoff = 0.75,
                       seed = 1050,
                       burn_in = 100,
                       return_nets = TRUE)

run_150 <- run_one_sim(T_obs = 150, N = 100, p = 8,
                       group_cutoff = 0.75,
                       seed = 1150,
                       burn_in = 100,
                       return_nets = TRUE)

run_300 <- run_one_sim(T_obs = 300, N = 100, p = 8,
                       group_cutoff = 0.75,
                       seed = 1300,
                       burn_in = 100,
                       return_nets = TRUE)
```


```{r}

###### True vs. Estimated network for A ##########
############# Network Plot ########################

par(mfrow = c(2, 3))  

##  T = 50, A matrices
set.seed(1)
layout_A50 <- qgraph(run_50$A_common,
                     layout    = "spring",
                     DoNotPlot = TRUE)$layout

qgraph(run_50$A_common,
       layout      = layout_A50,
       edge.labels = TRUE,
       title       = "True A, T = 50")

qgraph(run_50$A_est,
       layout      = layout_A50,
       edge.labels = TRUE,
       title       = "Estimated A, T = 50")

##  T = 150, A matrices 
set.seed(2)
layout_A150 <- qgraph(run_150$A_common,
                      layout    = "spring",
                      DoNotPlot = TRUE)$layout

qgraph(run_150$A_common,
       layout      = layout_A150,
       edge.labels = TRUE,
       title       = "True A, T = 150")

qgraph(run_150$A_est,
       layout      = layout_A150,
       edge.labels = TRUE,
       title       = "Estimated A, T = 150")

## T = 300, A matrices 
set.seed(3)
layout_A300 <- qgraph(run_300$A_common,
                      layout    = "spring",
                      DoNotPlot = TRUE)$layout

qgraph(run_300$A_common,
       layout      = layout_A300,
       edge.labels = TRUE,
       title       = "True A, T = 300")

qgraph(run_300$A_est,
       layout      = layout_A300,
       edge.labels = TRUE,
       title       = "Estimated A, T = 300")

par(mfrow = c(1,1))  # reset

```


```{r}

###### True vs. Estimated network for $\Phi$ #######
############# Network Plot ########################

par(mfrow = c(2, 3))

##  T = 50, Phi 
set.seed(4)
layout_Phi50 <- qgraph(run_50$Phi_common,
                       layout    = "spring",
                       DoNotPlot = TRUE)$layout

qgraph(run_50$Phi_common,
       layout      = layout_Phi50,
       edge.labels = TRUE,
       title       = "True Phi, T = 50")

qgraph(run_50$Phi_est,
       layout      = layout_Phi50,
       edge.labels = TRUE,
       title       = "Estimated Phi, T = 50")

##  T = 150, Phi 
set.seed(5)
layout_Phi150 <- qgraph(run_150$Phi_common,
                        layout    = "spring",
                        DoNotPlot = TRUE)$layout

qgraph(run_150$Phi_common,
       layout      = layout_Phi150,
       edge.labels = TRUE,
       title       = "True Phi, T = 150")

qgraph(run_150$Phi_est,
       layout      = layout_Phi150,
       edge.labels = TRUE,
       title       = "Estimated Phi, T = 150")

##  T = 300, Phi
set.seed(6)
layout_Phi300 <- qgraph(run_300$Phi_common,
                        layout    = "spring",
                        DoNotPlot = TRUE)$layout

qgraph(run_300$Phi_common,
       layout      = layout_Phi300,
       edge.labels = TRUE,
       title       = "True Phi, T = 300")

qgraph(run_300$Phi_est,
       layout      = layout_Phi300,
       edge.labels = TRUE,
       title       = "Estimated Phi, T = 300")

par(mfrow = c(1,1))

```

