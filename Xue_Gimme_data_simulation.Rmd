---
title: "STAT293_GIMME"
author: "Yijia Xue"
date: "2025-11-21"
output: pdf_document
---


```{r}
library(MASS)
set.seed(123)
```

1. Global Setting

```{r}
p<-4 # number of variables
T<-200 # time points per subject
N<-100# number of subjects

#diagonal residual covariance 
Psi<- 0.05*diag(p)
```

2. Specify common vs individual structure for A and $\Phi$

```{r}
A_common<- matrix(0,p,p)

A_common[2,1]<-0.3
A_common[3,2]<-0.25
A_common[4,3]<-0.3

# positions of individual-specific A entries
# each row = (i, j) meaning η_i,t <- η_j,t is subject-specific

A_indiv_pos<-rbind(
  c(1,3),
  c(4,1)
)

# common lag-1 matrix
Phi_common<- matrix(0,p,p)
diag(Phi_common)<-0.5
Phi_common[2,1]<-0.3

Phi_indiv_pos<- rbind(
  c(3,4)
)
```

3. Functions to generate subject-specific $A_i$ and $\Phi_i$

```{r}
generate_A_i <- function(A_common, A_indiv_pos,
                         mean_ind = 0.25, sd_ind = 0.05) {
  A <- A_common
  if (!is.null(A_indiv_pos) && nrow(A_indiv_pos) > 0) {
    for (k in 1:nrow(A_indiv_pos)) {
      i <- A_indiv_pos[k, 1]
      j <- A_indiv_pos[k, 2]
      A[i, j] <- rnorm(1, mean_ind, sd_ind)   # subject-specific edge
    }
  }
  diag(A) <- 0  # enforce zero diagonal for contemporaneous matrix
  A
}

generate_Phi_i <- function(Phi_common, Phi_indiv_pos,
                           mean_ind = 0.25, sd_ind = 0.05) {
  Phi <- Phi_common
  if (!is.null(Phi_indiv_pos) && nrow(Phi_indiv_pos) > 0) {
    for (k in 1:nrow(Phi_indiv_pos)) {
      i <- Phi_indiv_pos[k, 1]
      j <- Phi_indiv_pos[k, 2]
      Phi[i, j] <- rnorm(1, mean_ind, sd_ind)   # subject-specific lagged edge
    }
  }
  Phi
}
```

4. Simulate one subject given $A_i$ and $\Phi_i$ 

$\eta_{t} = A_{i}\,\eta_{t} + \Phi_{i}\,\eta_{t-1} + \zeta_{t}$

$[\eta_{t}=(I - A_{i})^{-1}\left[\Phi_{i}\,\eta_{t-1} + \zeta_{t}\right]$

```{r}
simulate_subject <- function(T, A, Phi, Psi) {
  p <- nrow(A)
  X <- matrix(NA, nrow = T, ncol = p)
  colnames(X) <- paste0("X", 1:p)

  # initial state eta_1 ~ N(0, I)
  X[1, ] <- mvrnorm(1, mu = rep(0, p), Sigma = diag(p))

  # (I - A)^(-1)
  M <- solve(diag(p) - A)

  for (t in 2:T) {
    zeta_t <- mvrnorm(1, mu = rep(0, p), Sigma = Psi)  #zeta is the white noise
    X[t, ] <- M %*% (Phi %*% X[t - 1, ] + zeta_t)
  }

  X
}
```

5. Generate all subjects

```{r}
A_list   <- vector("list", N)
Phi_list <- vector("list", N)
X_list   <- vector("list", N)

for (s in 1:N) {
  A_i   <- generate_A_i(A_common,  A_indiv_pos)
  Phi_i <- generate_Phi_i(Phi_common, Phi_indiv_pos)

  A_list[[s]]   <- A_i
  Phi_list[[s]] <- Phi_i
  X_list[[s]]   <- simulate_subject(T, A_i, Phi_i, Psi)
}

```

6. Put into long format

```{r}
to_long <- function(X_list) {
  do.call(rbind, lapply(seq_along(X_list), function(id) {
    X <- X_list[[id]]
    data.frame(
      id   = id,
      time = 1:nrow(X),
      X
    )
  }))
}

dat_long <- to_long(X_list)

head(dat_long)
tail(dat_long)

```
    #########  GIMME Simulation. ############
    #########################################
    #########################################
    
```{r}
length(X_list)
dim(X_list[[1]])
dir.create("sim_data", showWarnings = FALSE)

for (s in seq_along(X_list)) {
  fname <- file.path("sim_data", paste0("sub", s, ".txt"))
  write.table(
    X_list[[s]],
    file      = fname,
    row.names = FALSE,
    col.names = TRUE,
    sep       = " "   
  )
}
```
    
```{r}
library(gimme)
dir.create("sim_results", showWarnings = FALSE)

fit <- gimme(          
  data      = "sim_data",  
  out       = "sim_results",
  sep       = "",           
  header    = TRUE,         
  ar        = TRUE,         
  plot      = FALSE,        
  subgroup  = FALSE,       
  paths     = NULL,         
  groupcutoff = .75,
  subcutoff   = .50
)
```

```{r}
library(dplyr)
library(tidyr)
library(readr)
library(qgraph)


###. Compare true vs estimated group-level matrices

list.files("sim_results")
PCM <- as.matrix(read.csv("sim_results/summaryPathCountsMatrix.csv",
                          check.names = FALSE))
head(PCM)

p <- nrow(PCM)
lag_cols <- grep("lag", colnames(PCM))
Phi_counts <- PCM[, lag_cols, drop = FALSE]
A_counts <- PCM[, -lag_cols, drop = FALSE]
N_subj <- max(PCM)
group_cutoff <- 0.75
Phi_est <- (Phi_counts >= group_cutoff * N_subj)
A_est   <- (A_counts  >= group_cutoff * N_subj)
Phi_est <- +Phi_est
A_est   <- +A_est

rownames(A_est)   <- rownames(PCM)
colnames(A_est)   <- gsub("lag", "", colnames(A_counts))
rownames(Phi_est) <- rownames(PCM)
colnames(Phi_est) <- gsub("lag", "", colnames(Phi_counts))
diag(A_est) <- 0
A_est
Phi_est



compare_mats <- function(M_true, M_est, tol = 1e-8) {
  
  # treat any nonzero entry as an edge
  true_edge <- abs(M_true) > tol
  est_edge  <- abs(M_est)  > tol
  
  TP <- sum(true_edge & est_edge)
  FP <- sum(!true_edge & est_edge)
  FN <- sum(true_edge & !est_edge)
  TN <- sum(!true_edge & !est_edge)
  
  data.frame(
    TP = TP,
    FP = FP,
    FN = FN,
    TN = TN,
    sensitivity = ifelse((TP + FN) == 0, NA, TP / (TP + FN)),
    specificity = ifelse((TN + FP) == 0, NA, TN / (TN + FP)),
    precision   = ifelse((TP + FP) == 0, NA, TP / (TP + FP))
  )
}


cat("===== Group-level Contemporaneous A =====\n")
compare_mats(A_common, A_est)

cat("===== Group-level Lagged Φ =====\n")
compare_mats(Phi_common, Phi_est)
```


```{r}
library(qgraph)

layout_mat <- "spring"   # or "circle"

## A: contemporaneous
par(mfrow = c(1, 2))
qgraph(A_common,
       layout = layout_mat,
       edge.labels = TRUE,
       title = "True A (contemporaneous)")

qgraph(A_est,
       layout = layout_mat,
       edge.labels = TRUE,
       title = "Estimated A (contemporaneous)")

## Φ: lagged
par(mfrow = c(1, 2))
qgraph(Phi_common,
       layout = layout_mat,
       edge.labels = TRUE,
       title = "True Phi (lagged)")

qgraph(Phi_est,
       layout = layout_mat,
       edge.labels = TRUE,
       title = "Estimated Phi (lagged)")

par(mfrow = c(1, 1))

```
```{r}
qgraph(A_common)
qgraph(A_est)
qgraph(Phi_common)
qgraph(Phi_est)
```

